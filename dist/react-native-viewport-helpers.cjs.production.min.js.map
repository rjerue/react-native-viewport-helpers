{"version":3,"file":"react-native-viewport-helpers.cjs.production.min.js","sources":["../src/index.tsx","../src/observer.tsx","../src/nativeObserver.tsx"],"sourcesContent":["import * as React from 'react';\nimport { View } from 'react-native';\nimport {\n  useState,\n  useEffect,\n  useLayoutEffect,\n  EffectCallback,\n  useCallback,\n} from 'react';\nimport { observe } from './observer';\n\n/**\n * Hook to run when ref is in view\n * @param ref Ref to be in view\n * @param onVisible Effect to run when in view\n * @param dependencies Dependencies for the hook\n * @param delay delay to poll on, by default 500ms\n */\nexport function useIsInViewPortEffect(\n  ref: React.MutableRefObject<View | HTMLDivElement | null>,\n  onVisible: EffectCallback = () => {},\n  dependencies: any[] = [],\n  delay = 500\n) {\n  const [interval, setVPInterval] = useState<NodeJS.Timeout | null>(null);\n  const [isVisible, setIsVisible] = useState<boolean>(false);\n  const clear = useCallback(() => {\n    if (interval) {\n      clearInterval(interval);\n    }\n    setVPInterval(null);\n  }, [interval]);\n\n  useLayoutEffect(() => {\n    setVPInterval(\n      setInterval(() => {\n        if (!ref.current) {\n          return;\n        }\n        observe(ref.current, isVisible, setIsVisible);\n      }, delay)\n    );\n    return clear;\n  }, [ref, delay, isVisible, ...dependencies]);\n\n  useEffect(() => {\n    if (isVisible) {\n      const effect = onVisible();\n      return effect;\n    }\n  }, [isVisible]);\n  return isVisible;\n}\n","import { View } from 'react-native';\nimport { nativeObserve } from './nativeObserver';\n\nexport const observe = (\n  ref: Element | View,\n  isVisible: boolean,\n  setIsVisible: (isVisible: () => boolean) => void\n) => {\n  nativeObserve(ref as View, isVisible, setIsVisible);\n};\n","import { View, Dimensions } from 'react-native';\n\nexport const nativeObserve = (\n  ref: View,\n  wasVisible: boolean,\n  setIsVisible: (isVisible: () => boolean) => void\n) => {\n  (ref as View).measure((_x, _y, width, height, pageX, pageY) => {\n    const state = {\n      rectTop: pageY,\n      rectBottom: pageY + height,\n      rectWidth: pageX + width,\n    };\n    const window = Dimensions.get('screen');\n    const isVisible =\n      state.rectBottom !== 0 &&\n      state.rectTop >= 0 &&\n      state.rectBottom <= window.height &&\n      state.rectWidth > 0 &&\n      state.rectWidth <= window.width;\n    if (wasVisible !== isVisible) {\n      setIsVisible(() => isVisible);\n    }\n  });\n};\n"],"names":["ref","onVisible","dependencies","delay","useState","interval","setVPInterval","isVisible","setIsVisible","clear","useCallback","clearInterval","useLayoutEffect","setInterval","current","wasVisible","measure","_x","_y","width","height","pageX","pageY","state","window","Dimensions","get","nativeObserve","observe","useEffect"],"mappings":"4FAkBA,SACEA,EACAC,EACAC,EACAC,YAFAF,IAAAA,EAA4B,uBAC5BC,IAAAA,EAAsB,aACtBC,IAAAA,EAAQ,WAE0BC,WAAgC,MAA3DC,OAAUC,SACiBF,YAAkB,GAA7CG,OAAWC,OACZC,EAAQC,cAAY,WACpBL,GACFM,cAAcN,GAEhBC,EAAc,OACb,CAACD,WAEJO,kBAAgB,kBACdN,EACEO,YAAY,WACLb,EAAIc,SCjCM,SACrBd,EACAO,EACAC,ICJ2B,SAC3BR,EACAe,EACAP,GAECR,EAAagB,QAAQ,SAACC,EAAIC,EAAIC,EAAOC,EAAQC,EAAOC,OAC7CC,EACKD,EADLC,EAEQD,EAAQF,EAFhBG,EAGOF,EAAQF,EAEfK,EAASC,aAAWC,IAAI,UACxBnB,EACiB,IAArBgB,GACAA,GAAiB,GACjBA,GAAoBC,EAAOJ,QAC3BG,EAAkB,GAClBA,GAAmBC,EAAOL,MACxBJ,IAAeR,GACjBC,EAAa,kBAAMD,MDbvBoB,CAAc3B,EAAaO,EAAWC,GD+BhCoB,CAAQ5B,EAAIc,QAASP,EAAWC,IAC/BL,IAEEM,IACLT,EAAKG,EAAOI,UAAcL,IAE9B2B,YAAU,cACJtB,SACaN,KAGhB,CAACM,IACGA"}